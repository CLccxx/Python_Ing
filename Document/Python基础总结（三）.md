### 模块
随着代码越写越多，为了更方便的维护和查找代码，我们可以把函数分组放在不同的文件中，这样每个文件包含的代码相对较少，并且集中。在python中，一个.py文件就称之为一个模块

#### 模块的优点
使用模块大大的提高了代码的可维护性，并且避免了函数名和变量名的冲突，相同名字的函数和变量完全可以分别存在不同的模块中。

Python为了防止模块名重复，引入了包（Packge）的概念，引入包之后，只要顶层包名不与其他包冲突，那所有的模块都不会与其他包冲突。

需要注意的是每一个包下面都会有一个`__init__.py`的文件。这个文件必须存在，否则Python会把这个目录当成一个普通目录，而不是一个包。`__init__.py`可以是空文件，也可以有Python代码，因为`__init__.py`本身就是一个模块，而他的模块名就是包名。类似的，包也可以有多级目录，组成多级层次的包结构。

通过下面一个例子看一下

```
mycompany
├─ com
│  ├─ __init__.py
│  ├─ student.py
│  └─ person.py
├─ __init__.py
├─ tool.py
└─ person.py
```

两个person.py的模块名分别为`mycompany.person` 和 `mycompany.com.person`

注意：创建模块时要注意命名，不能和Python自带的模块名称冲突。

#### 总结
模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。创建自己的模块时需要注意。

1. 模块名要遵循Python变量命名规范，不要使用中文，特殊字符
2. 模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import ，若成功则说明系统存在此模块。

#### 模块的使用
Python内置了很多非常有用的模块，只要安装完毕，这些模块就可以立即使用。

#### 作用域
在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量不希望别人知道其内部实现，仅仅在模块内使用。在Python中，通过 `__` 前缀来实现。

类似的 `_funcName` 或 `__funcName`这样的函数或者变量就是私有的（private），不应该直接使用。

需要注意的是python中并没有真正的私有方法和私有属性，上面说的私有方法和属性不应该直接被使用而不是不能。

python中可以通过调用方法和属性的全名来调用私用方法和属性，但是这样就失去了私有的意义。从编程约定俗成的规则来看，不应该引用private的函数或变量。

#### 面向对象编程
有编程基础的，这块儿不在赘述

#### 类和对象
类和对象的定义这里不再赘述，直接来看python如何定义类和创建对象

```
# 定义类
class 类名():
      方法列表

# 定义类有两种形式：经典类(旧式)和新式类
# 旧式类
class Person:
class Person():

# 新式类定义
class Person(object):
      # func
```

新式类中`object`是Python里所有类的顶级父类。类名的命名规则按照大驼峰命名法。

```
# 创建对象

对象名1 = 类名()
对象名2 = 类名()
对象名3 = 类名()

person = Person()
person对象是Person类实例化的一个对象

# 为对象动态添加属性
person.name = "hello world"
person.age = 18
```

### init方法
init方法是Python内部提供的两个下划线开始，两个下划线结束的方法。类似的方法称为魔法方法。

`__init__()`就是一个魔法方法，通常用来做属性初始化或赋值操作。

如果类中没有写`__init__()`方法，Python会自动创建，但是不执行任何操作。因此一个类中无论是否重写`__init__()`方法都一定存在。

通常重写`__init__()`方法来完成想要的功能。

举个例子：

```
class Person(object):
    def __init__(self):
        """ ⽅法，⽤来做变量初始化 或 赋值 操作，在类实例化对象的时候，会被⾃动调⽤"""
        self.name = "xx_Cc"  # 姓名
        self.age = 26  # 年龄
    def run(self):
        """实例⽅法"""
        print("正在跑步...")

    def eat(self):
        """实例⽅法"""
        print("正在吃饭...")

# 实例化了⼀个Person对象，并⾃动调⽤__init__()⽅法
xx_cc = Person()

# 通过.成员选择运算符，获取对象的实例⽅法
xx_cc.run()
xx_cc.eat()
print(xx_cc.name, xx_cc.age)
```

注意：

* `__init__()`方法，在创建一个对象时默认被调用，不需要手动调用。
* `__init__(self)`中self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。

#### 有参数的`__init__()`方法

以上面代码为例，为`__init__()`添加参数

```
class Person(object):
    def __init__(self, name, age):
        """ ⽅法，⽤来做变量初始化 或 赋值 操作，在类实例化对象的时候，会被⾃动调⽤"""
        self.name = name  # 姓名
        self.age = age  # 年龄
    def run(self):
        """实例⽅法"""
        print("%s 正在跑步..." % self.name)

    def eat(self):
        """实例⽅法"""
        print("%s 正在吃饭..." % self.name)

# 实例化了⼀个Person对象，并⾃动调⽤__init__()⽅法
xx_cc = Person("xx_cc",18)

# 通过.成员选择运算符，获取对象的实例⽅法

xx_cc.run()
xx_cc.eat()

print(xx_cc.name, xx_cc.age)


# 打印内容
xx_cc 正在跑步...
xx_cc 正在吃饭...
xx_cc 18
```

注意：

* 通过一个类，可以创建多个对象。每个对象的属性是各自保存的，都有各自独立的地址。
* 但是实例方法是所有对象共享的，只占用一份内存空间。类会通过self来判断是哪个对象调用了实例方法。
* 在类内部获取属性和实例方法，通过self获取。
* 在类外部获取属性和实例方法，通过对象名获取。

#### `__str__()`方法
 
`__str__()`方法是一个魔法方法，用来显示信息，该方法需要return一个数据，并且只有self一个参数，当在类的外部print(实例对象)则打印返回的数据。

`__str__()`方法默认打印对象的内存地址。

举个例子

```
class Person(object):
    def __init__(self, name, age):
        """ ⽅法，⽤来做变量初始化 或 赋值 操作，在类实例化对象的时候，会被⾃动调⽤"""
        self.name = name  # 姓名
        self.age = age  # 年龄

    def __str__(self):
        return "姓名%s \n年龄 %d" % (self.name, self.age)

# 实例化了⼀个Person对象，并⾃动调⽤__init__()⽅法
xx_cc = Person("xx_cc",18)

print(xx_cc.name, xx_cc.age)
print(xx_cc)

# 打印内容
xx_cc 18
姓名xx_cc 
年龄 18


# 如果不实现__str__()方法，则打印对象的内存地址。
<__main__.Person object at 0x102d2b128>
```

#### `__del__()`方法

与`__init__()`方法类似，当删除对象时，pyhton解释器会默认调用`__del__()`方法，来删除实例对象。

举个例子

```
class Person(object):
    def __init__(self, name, age):
        """ ⽅法，⽤来做变量初始化 或 赋值 操作，在类实例化对象的时候，会被⾃动调⽤"""
        self.name = name  # 姓名
        self.age = age  # 年龄
        
    def __del__(self):
        print("__del__方法调用了")
        print("从内存中删除 %s" % self.name)

# 实例化了⼀个Person对象，并⾃动调⽤__init__()⽅法
xx_cc = Person("xx_cc",18)

xx_cc1 = xx_cc
xx_cc2 = xx_cc

print("%d 被删除1次" % id(xx_cc1))
del(xx_cc1)

print("%d 被删除2次" % id(xx_cc2))
del(xx_cc2)

# 打印内容
4480242632 被删除1次
4480242632 被删除2次
__del__方法调用了
从内存中删除 xx_cc
```

注意：

* 当有变量保存了一个对象的一用时，此对象的引用计数就会加1。当删除了引用时，引用计数就会减1。
* 当使用`del()`删除变量指向的对象时，则会减少对象的引用计数。如果对象的引用计数大于1，那么会让这个对象的引用计数减1，当对象的引用计数减为0的时候，对象才会被真正的删除，对象所占用的内存会被回收。

### 继承

继承描述的是多个类事件的所属关系，如果一个类A里面的属性和方法可以复用，则可以通过继承的方式，传递到类B里。那么类A就是基类，也叫作父类，类B就是派生类，也叫做子类。

Python里面不仅支持单继承而且支持多继承。

```
# 单继承
class 类名(父类名):
    pass
    
# 多继承
class 类名(父类A, 父类B):
    pass
```

注意：

1. 子类会继承父类的属性和方法
2. 子类可以继承多个父类，也继承所有的父类的属性和方法
3. 如果多个父类中有同名的属性和方法，则默认使用第一个父类的属性和方法。
4. 多个父类中，不重名的属性和方法，不会有任何影响。
5. 子类可以重写父类的方法和属性，如果子类重写了父类的同名方法和属性，则默认使用子类的方法和属性。
6. 子类调用父类的同名属性和方法`父类类名.父类方法(self)`
7. 无论何时何地，self都表示是子类对象。在调用父类方法时，通过传递self参数，来控制方法和属性的访问或修改。

#### super()的使用

也可以使用super来调用父类的方法，
self指定类的继承链子。

```
super(子类名,self).方法名()
# 继承链中（子类名）的下一个类。如果没有找到会继续往链条下一个类去查找。
```

子类继承了多个父类，如果父类类名修改了，那么子类也要涉及多次修改。而且需要重复写多次调用，显的代码臃肿。

使用super()可以逐一调用所有的父类方法，并且只执行一次。调用顺序遵循mro类属性的顺序。

如果继承了多个父类，且父类都有同名方法，则默认只执行第一个父类的(同名方法只执行一次，目前super()不支持执行多个父类的同名方法)

super()在python2.3之后才有的机制，用于通常单继承的多层继承。

#### 多态

多态：定义时的类型和运行时的类型不一样，此时就成为多态。Python的多态，就是弱化类型，重点在于对象参数是否有指定的属性和方法，如果有就认定合适，而不关心对象的类型是否正确。

```
class Father(object):
    def show(self):
        print('F1.show')

class Sun1(Father):
    def show(self):
        print('Sun1.show')

class Sun2(Father):
    def show(self):
        print('Sun2.show')

def Func(obj):
    obj.show()
# python是弱类型，即⽆论传递过来的是什么，obj变量都能够指向它，这也就没有所谓的多态了（弱化了这个概念）。

s1_obj = Sun1()
Func(s1_obj)

s2_obj = Sun2()
Func(s2_obj)
```

